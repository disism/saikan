// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/disism/saikan/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/disism/saikan/ent/actors"
	"github.com/disism/saikan/ent/albums"
	"github.com/disism/saikan/ent/artists"
	"github.com/disism/saikan/ent/audiobooks"
	"github.com/disism/saikan/ent/categorys"
	"github.com/disism/saikan/ent/devices"
	"github.com/disism/saikan/ent/directors"
	"github.com/disism/saikan/ent/files"
	"github.com/disism/saikan/ent/images"
	"github.com/disism/saikan/ent/musics"
	"github.com/disism/saikan/ent/oidc"
	"github.com/disism/saikan/ent/playlists"
	"github.com/disism/saikan/ent/users"
	"github.com/disism/saikan/ent/videos"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Actors is the client for interacting with the Actors builders.
	Actors *ActorsClient
	// Albums is the client for interacting with the Albums builders.
	Albums *AlbumsClient
	// Artists is the client for interacting with the Artists builders.
	Artists *ArtistsClient
	// Audiobooks is the client for interacting with the Audiobooks builders.
	Audiobooks *AudiobooksClient
	// Categorys is the client for interacting with the Categorys builders.
	Categorys *CategorysClient
	// Devices is the client for interacting with the Devices builders.
	Devices *DevicesClient
	// Directors is the client for interacting with the Directors builders.
	Directors *DirectorsClient
	// Files is the client for interacting with the Files builders.
	Files *FilesClient
	// Images is the client for interacting with the Images builders.
	Images *ImagesClient
	// Musics is the client for interacting with the Musics builders.
	Musics *MusicsClient
	// Oidc is the client for interacting with the Oidc builders.
	Oidc *OidcClient
	// Playlists is the client for interacting with the Playlists builders.
	Playlists *PlaylistsClient
	// Users is the client for interacting with the Users builders.
	Users *UsersClient
	// Videos is the client for interacting with the Videos builders.
	Videos *VideosClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Actors = NewActorsClient(c.config)
	c.Albums = NewAlbumsClient(c.config)
	c.Artists = NewArtistsClient(c.config)
	c.Audiobooks = NewAudiobooksClient(c.config)
	c.Categorys = NewCategorysClient(c.config)
	c.Devices = NewDevicesClient(c.config)
	c.Directors = NewDirectorsClient(c.config)
	c.Files = NewFilesClient(c.config)
	c.Images = NewImagesClient(c.config)
	c.Musics = NewMusicsClient(c.config)
	c.Oidc = NewOidcClient(c.config)
	c.Playlists = NewPlaylistsClient(c.config)
	c.Users = NewUsersClient(c.config)
	c.Videos = NewVideosClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		Actors:     NewActorsClient(cfg),
		Albums:     NewAlbumsClient(cfg),
		Artists:    NewArtistsClient(cfg),
		Audiobooks: NewAudiobooksClient(cfg),
		Categorys:  NewCategorysClient(cfg),
		Devices:    NewDevicesClient(cfg),
		Directors:  NewDirectorsClient(cfg),
		Files:      NewFilesClient(cfg),
		Images:     NewImagesClient(cfg),
		Musics:     NewMusicsClient(cfg),
		Oidc:       NewOidcClient(cfg),
		Playlists:  NewPlaylistsClient(cfg),
		Users:      NewUsersClient(cfg),
		Videos:     NewVideosClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		Actors:     NewActorsClient(cfg),
		Albums:     NewAlbumsClient(cfg),
		Artists:    NewArtistsClient(cfg),
		Audiobooks: NewAudiobooksClient(cfg),
		Categorys:  NewCategorysClient(cfg),
		Devices:    NewDevicesClient(cfg),
		Directors:  NewDirectorsClient(cfg),
		Files:      NewFilesClient(cfg),
		Images:     NewImagesClient(cfg),
		Musics:     NewMusicsClient(cfg),
		Oidc:       NewOidcClient(cfg),
		Playlists:  NewPlaylistsClient(cfg),
		Users:      NewUsersClient(cfg),
		Videos:     NewVideosClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Actors.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Actors, c.Albums, c.Artists, c.Audiobooks, c.Categorys, c.Devices,
		c.Directors, c.Files, c.Images, c.Musics, c.Oidc, c.Playlists, c.Users,
		c.Videos,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Actors, c.Albums, c.Artists, c.Audiobooks, c.Categorys, c.Devices,
		c.Directors, c.Files, c.Images, c.Musics, c.Oidc, c.Playlists, c.Users,
		c.Videos,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ActorsMutation:
		return c.Actors.mutate(ctx, m)
	case *AlbumsMutation:
		return c.Albums.mutate(ctx, m)
	case *ArtistsMutation:
		return c.Artists.mutate(ctx, m)
	case *AudiobooksMutation:
		return c.Audiobooks.mutate(ctx, m)
	case *CategorysMutation:
		return c.Categorys.mutate(ctx, m)
	case *DevicesMutation:
		return c.Devices.mutate(ctx, m)
	case *DirectorsMutation:
		return c.Directors.mutate(ctx, m)
	case *FilesMutation:
		return c.Files.mutate(ctx, m)
	case *ImagesMutation:
		return c.Images.mutate(ctx, m)
	case *MusicsMutation:
		return c.Musics.mutate(ctx, m)
	case *OidcMutation:
		return c.Oidc.mutate(ctx, m)
	case *PlaylistsMutation:
		return c.Playlists.mutate(ctx, m)
	case *UsersMutation:
		return c.Users.mutate(ctx, m)
	case *VideosMutation:
		return c.Videos.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ActorsClient is a client for the Actors schema.
type ActorsClient struct {
	config
}

// NewActorsClient returns a client for the Actors from the given config.
func NewActorsClient(c config) *ActorsClient {
	return &ActorsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actors.Hooks(f(g(h())))`.
func (c *ActorsClient) Use(hooks ...Hook) {
	c.hooks.Actors = append(c.hooks.Actors, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actors.Intercept(f(g(h())))`.
func (c *ActorsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Actors = append(c.inters.Actors, interceptors...)
}

// Create returns a builder for creating a Actors entity.
func (c *ActorsClient) Create() *ActorsCreate {
	mutation := newActorsMutation(c.config, OpCreate)
	return &ActorsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Actors entities.
func (c *ActorsClient) CreateBulk(builders ...*ActorsCreate) *ActorsCreateBulk {
	return &ActorsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActorsClient) MapCreateBulk(slice any, setFunc func(*ActorsCreate, int)) *ActorsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActorsCreateBulk{err: fmt.Errorf("calling to ActorsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActorsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActorsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Actors.
func (c *ActorsClient) Update() *ActorsUpdate {
	mutation := newActorsMutation(c.config, OpUpdate)
	return &ActorsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActorsClient) UpdateOne(a *Actors) *ActorsUpdateOne {
	mutation := newActorsMutation(c.config, OpUpdateOne, withActors(a))
	return &ActorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActorsClient) UpdateOneID(id int) *ActorsUpdateOne {
	mutation := newActorsMutation(c.config, OpUpdateOne, withActorsID(id))
	return &ActorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Actors.
func (c *ActorsClient) Delete() *ActorsDelete {
	mutation := newActorsMutation(c.config, OpDelete)
	return &ActorsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActorsClient) DeleteOne(a *Actors) *ActorsDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActorsClient) DeleteOneID(id int) *ActorsDeleteOne {
	builder := c.Delete().Where(actors.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActorsDeleteOne{builder}
}

// Query returns a query builder for Actors.
func (c *ActorsClient) Query() *ActorsQuery {
	return &ActorsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActors},
		inters: c.Interceptors(),
	}
}

// Get returns a Actors entity by its id.
func (c *ActorsClient) Get(ctx context.Context, id int) (*Actors, error) {
	return c.Query().Where(actors.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActorsClient) GetX(ctx context.Context, id int) *Actors {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ActorsClient) Hooks() []Hook {
	return c.hooks.Actors
}

// Interceptors returns the client interceptors.
func (c *ActorsClient) Interceptors() []Interceptor {
	return c.inters.Actors
}

func (c *ActorsClient) mutate(ctx context.Context, m *ActorsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActorsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActorsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActorsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Actors mutation op: %q", m.Op())
	}
}

// AlbumsClient is a client for the Albums schema.
type AlbumsClient struct {
	config
}

// NewAlbumsClient returns a client for the Albums from the given config.
func NewAlbumsClient(c config) *AlbumsClient {
	return &AlbumsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `albums.Hooks(f(g(h())))`.
func (c *AlbumsClient) Use(hooks ...Hook) {
	c.hooks.Albums = append(c.hooks.Albums, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `albums.Intercept(f(g(h())))`.
func (c *AlbumsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Albums = append(c.inters.Albums, interceptors...)
}

// Create returns a builder for creating a Albums entity.
func (c *AlbumsClient) Create() *AlbumsCreate {
	mutation := newAlbumsMutation(c.config, OpCreate)
	return &AlbumsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Albums entities.
func (c *AlbumsClient) CreateBulk(builders ...*AlbumsCreate) *AlbumsCreateBulk {
	return &AlbumsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlbumsClient) MapCreateBulk(slice any, setFunc func(*AlbumsCreate, int)) *AlbumsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlbumsCreateBulk{err: fmt.Errorf("calling to AlbumsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlbumsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlbumsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Albums.
func (c *AlbumsClient) Update() *AlbumsUpdate {
	mutation := newAlbumsMutation(c.config, OpUpdate)
	return &AlbumsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlbumsClient) UpdateOne(a *Albums) *AlbumsUpdateOne {
	mutation := newAlbumsMutation(c.config, OpUpdateOne, withAlbums(a))
	return &AlbumsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlbumsClient) UpdateOneID(id uint64) *AlbumsUpdateOne {
	mutation := newAlbumsMutation(c.config, OpUpdateOne, withAlbumsID(id))
	return &AlbumsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Albums.
func (c *AlbumsClient) Delete() *AlbumsDelete {
	mutation := newAlbumsMutation(c.config, OpDelete)
	return &AlbumsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlbumsClient) DeleteOne(a *Albums) *AlbumsDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlbumsClient) DeleteOneID(id uint64) *AlbumsDeleteOne {
	builder := c.Delete().Where(albums.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlbumsDeleteOne{builder}
}

// Query returns a query builder for Albums.
func (c *AlbumsClient) Query() *AlbumsQuery {
	return &AlbumsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlbums},
		inters: c.Interceptors(),
	}
}

// Get returns a Albums entity by its id.
func (c *AlbumsClient) Get(ctx context.Context, id uint64) (*Albums, error) {
	return c.Query().Where(albums.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlbumsClient) GetX(ctx context.Context, id uint64) *Albums {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryImage queries the image edge of a Albums.
func (c *AlbumsClient) QueryImage(a *Albums) *ImagesQuery {
	query := (&ImagesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(albums.Table, albums.FieldID, id),
			sqlgraph.To(images.Table, images.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, albums.ImageTable, albums.ImageColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMusics queries the musics edge of a Albums.
func (c *AlbumsClient) QueryMusics(a *Albums) *MusicsQuery {
	query := (&MusicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(albums.Table, albums.FieldID, id),
			sqlgraph.To(musics.Table, musics.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, albums.MusicsTable, albums.MusicsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Albums.
func (c *AlbumsClient) QueryUsers(a *Albums) *UsersQuery {
	query := (&UsersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(albums.Table, albums.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, albums.UsersTable, albums.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtists queries the artists edge of a Albums.
func (c *AlbumsClient) QueryArtists(a *Albums) *ArtistsQuery {
	query := (&ArtistsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(albums.Table, albums.FieldID, id),
			sqlgraph.To(artists.Table, artists.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, albums.ArtistsTable, albums.ArtistsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AlbumsClient) Hooks() []Hook {
	return c.hooks.Albums
}

// Interceptors returns the client interceptors.
func (c *AlbumsClient) Interceptors() []Interceptor {
	return c.inters.Albums
}

func (c *AlbumsClient) mutate(ctx context.Context, m *AlbumsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlbumsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlbumsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlbumsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlbumsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Albums mutation op: %q", m.Op())
	}
}

// ArtistsClient is a client for the Artists schema.
type ArtistsClient struct {
	config
}

// NewArtistsClient returns a client for the Artists from the given config.
func NewArtistsClient(c config) *ArtistsClient {
	return &ArtistsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artists.Hooks(f(g(h())))`.
func (c *ArtistsClient) Use(hooks ...Hook) {
	c.hooks.Artists = append(c.hooks.Artists, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artists.Intercept(f(g(h())))`.
func (c *ArtistsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artists = append(c.inters.Artists, interceptors...)
}

// Create returns a builder for creating a Artists entity.
func (c *ArtistsClient) Create() *ArtistsCreate {
	mutation := newArtistsMutation(c.config, OpCreate)
	return &ArtistsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artists entities.
func (c *ArtistsClient) CreateBulk(builders ...*ArtistsCreate) *ArtistsCreateBulk {
	return &ArtistsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtistsClient) MapCreateBulk(slice any, setFunc func(*ArtistsCreate, int)) *ArtistsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtistsCreateBulk{err: fmt.Errorf("calling to ArtistsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtistsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtistsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artists.
func (c *ArtistsClient) Update() *ArtistsUpdate {
	mutation := newArtistsMutation(c.config, OpUpdate)
	return &ArtistsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtistsClient) UpdateOne(a *Artists) *ArtistsUpdateOne {
	mutation := newArtistsMutation(c.config, OpUpdateOne, withArtists(a))
	return &ArtistsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtistsClient) UpdateOneID(id uint64) *ArtistsUpdateOne {
	mutation := newArtistsMutation(c.config, OpUpdateOne, withArtistsID(id))
	return &ArtistsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artists.
func (c *ArtistsClient) Delete() *ArtistsDelete {
	mutation := newArtistsMutation(c.config, OpDelete)
	return &ArtistsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtistsClient) DeleteOne(a *Artists) *ArtistsDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtistsClient) DeleteOneID(id uint64) *ArtistsDeleteOne {
	builder := c.Delete().Where(artists.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtistsDeleteOne{builder}
}

// Query returns a query builder for Artists.
func (c *ArtistsClient) Query() *ArtistsQuery {
	return &ArtistsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtists},
		inters: c.Interceptors(),
	}
}

// Get returns a Artists entity by its id.
func (c *ArtistsClient) Get(ctx context.Context, id uint64) (*Artists, error) {
	return c.Query().Where(artists.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtistsClient) GetX(ctx context.Context, id uint64) *Artists {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMusics queries the musics edge of a Artists.
func (c *ArtistsClient) QueryMusics(a *Artists) *MusicsQuery {
	query := (&MusicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artists.Table, artists.FieldID, id),
			sqlgraph.To(musics.Table, musics.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, artists.MusicsTable, artists.MusicsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlbums queries the albums edge of a Artists.
func (c *ArtistsClient) QueryAlbums(a *Artists) *AlbumsQuery {
	query := (&AlbumsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artists.Table, artists.FieldID, id),
			sqlgraph.To(albums.Table, albums.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, artists.AlbumsTable, artists.AlbumsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtistsClient) Hooks() []Hook {
	return c.hooks.Artists
}

// Interceptors returns the client interceptors.
func (c *ArtistsClient) Interceptors() []Interceptor {
	return c.inters.Artists
}

func (c *ArtistsClient) mutate(ctx context.Context, m *ArtistsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtistsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtistsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtistsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtistsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Artists mutation op: %q", m.Op())
	}
}

// AudiobooksClient is a client for the Audiobooks schema.
type AudiobooksClient struct {
	config
}

// NewAudiobooksClient returns a client for the Audiobooks from the given config.
func NewAudiobooksClient(c config) *AudiobooksClient {
	return &AudiobooksClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `audiobooks.Hooks(f(g(h())))`.
func (c *AudiobooksClient) Use(hooks ...Hook) {
	c.hooks.Audiobooks = append(c.hooks.Audiobooks, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `audiobooks.Intercept(f(g(h())))`.
func (c *AudiobooksClient) Intercept(interceptors ...Interceptor) {
	c.inters.Audiobooks = append(c.inters.Audiobooks, interceptors...)
}

// Create returns a builder for creating a Audiobooks entity.
func (c *AudiobooksClient) Create() *AudiobooksCreate {
	mutation := newAudiobooksMutation(c.config, OpCreate)
	return &AudiobooksCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Audiobooks entities.
func (c *AudiobooksClient) CreateBulk(builders ...*AudiobooksCreate) *AudiobooksCreateBulk {
	return &AudiobooksCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AudiobooksClient) MapCreateBulk(slice any, setFunc func(*AudiobooksCreate, int)) *AudiobooksCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AudiobooksCreateBulk{err: fmt.Errorf("calling to AudiobooksClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AudiobooksCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AudiobooksCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Audiobooks.
func (c *AudiobooksClient) Update() *AudiobooksUpdate {
	mutation := newAudiobooksMutation(c.config, OpUpdate)
	return &AudiobooksUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AudiobooksClient) UpdateOne(a *Audiobooks) *AudiobooksUpdateOne {
	mutation := newAudiobooksMutation(c.config, OpUpdateOne, withAudiobooks(a))
	return &AudiobooksUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AudiobooksClient) UpdateOneID(id int) *AudiobooksUpdateOne {
	mutation := newAudiobooksMutation(c.config, OpUpdateOne, withAudiobooksID(id))
	return &AudiobooksUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Audiobooks.
func (c *AudiobooksClient) Delete() *AudiobooksDelete {
	mutation := newAudiobooksMutation(c.config, OpDelete)
	return &AudiobooksDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AudiobooksClient) DeleteOne(a *Audiobooks) *AudiobooksDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AudiobooksClient) DeleteOneID(id int) *AudiobooksDeleteOne {
	builder := c.Delete().Where(audiobooks.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AudiobooksDeleteOne{builder}
}

// Query returns a query builder for Audiobooks.
func (c *AudiobooksClient) Query() *AudiobooksQuery {
	return &AudiobooksQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAudiobooks},
		inters: c.Interceptors(),
	}
}

// Get returns a Audiobooks entity by its id.
func (c *AudiobooksClient) Get(ctx context.Context, id int) (*Audiobooks, error) {
	return c.Query().Where(audiobooks.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AudiobooksClient) GetX(ctx context.Context, id int) *Audiobooks {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AudiobooksClient) Hooks() []Hook {
	return c.hooks.Audiobooks
}

// Interceptors returns the client interceptors.
func (c *AudiobooksClient) Interceptors() []Interceptor {
	return c.inters.Audiobooks
}

func (c *AudiobooksClient) mutate(ctx context.Context, m *AudiobooksMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AudiobooksCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AudiobooksUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AudiobooksUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AudiobooksDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Audiobooks mutation op: %q", m.Op())
	}
}

// CategorysClient is a client for the Categorys schema.
type CategorysClient struct {
	config
}

// NewCategorysClient returns a client for the Categorys from the given config.
func NewCategorysClient(c config) *CategorysClient {
	return &CategorysClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `categorys.Hooks(f(g(h())))`.
func (c *CategorysClient) Use(hooks ...Hook) {
	c.hooks.Categorys = append(c.hooks.Categorys, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `categorys.Intercept(f(g(h())))`.
func (c *CategorysClient) Intercept(interceptors ...Interceptor) {
	c.inters.Categorys = append(c.inters.Categorys, interceptors...)
}

// Create returns a builder for creating a Categorys entity.
func (c *CategorysClient) Create() *CategorysCreate {
	mutation := newCategorysMutation(c.config, OpCreate)
	return &CategorysCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Categorys entities.
func (c *CategorysClient) CreateBulk(builders ...*CategorysCreate) *CategorysCreateBulk {
	return &CategorysCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategorysClient) MapCreateBulk(slice any, setFunc func(*CategorysCreate, int)) *CategorysCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategorysCreateBulk{err: fmt.Errorf("calling to CategorysClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategorysCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategorysCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Categorys.
func (c *CategorysClient) Update() *CategorysUpdate {
	mutation := newCategorysMutation(c.config, OpUpdate)
	return &CategorysUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategorysClient) UpdateOne(ca *Categorys) *CategorysUpdateOne {
	mutation := newCategorysMutation(c.config, OpUpdateOne, withCategorys(ca))
	return &CategorysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategorysClient) UpdateOneID(id int) *CategorysUpdateOne {
	mutation := newCategorysMutation(c.config, OpUpdateOne, withCategorysID(id))
	return &CategorysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Categorys.
func (c *CategorysClient) Delete() *CategorysDelete {
	mutation := newCategorysMutation(c.config, OpDelete)
	return &CategorysDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategorysClient) DeleteOne(ca *Categorys) *CategorysDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategorysClient) DeleteOneID(id int) *CategorysDeleteOne {
	builder := c.Delete().Where(categorys.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategorysDeleteOne{builder}
}

// Query returns a query builder for Categorys.
func (c *CategorysClient) Query() *CategorysQuery {
	return &CategorysQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategorys},
		inters: c.Interceptors(),
	}
}

// Get returns a Categorys entity by its id.
func (c *CategorysClient) Get(ctx context.Context, id int) (*Categorys, error) {
	return c.Query().Where(categorys.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategorysClient) GetX(ctx context.Context, id int) *Categorys {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CategorysClient) Hooks() []Hook {
	return c.hooks.Categorys
}

// Interceptors returns the client interceptors.
func (c *CategorysClient) Interceptors() []Interceptor {
	return c.inters.Categorys
}

func (c *CategorysClient) mutate(ctx context.Context, m *CategorysMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategorysCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategorysUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategorysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategorysDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Categorys mutation op: %q", m.Op())
	}
}

// DevicesClient is a client for the Devices schema.
type DevicesClient struct {
	config
}

// NewDevicesClient returns a client for the Devices from the given config.
func NewDevicesClient(c config) *DevicesClient {
	return &DevicesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devices.Hooks(f(g(h())))`.
func (c *DevicesClient) Use(hooks ...Hook) {
	c.hooks.Devices = append(c.hooks.Devices, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devices.Intercept(f(g(h())))`.
func (c *DevicesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Devices = append(c.inters.Devices, interceptors...)
}

// Create returns a builder for creating a Devices entity.
func (c *DevicesClient) Create() *DevicesCreate {
	mutation := newDevicesMutation(c.config, OpCreate)
	return &DevicesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Devices entities.
func (c *DevicesClient) CreateBulk(builders ...*DevicesCreate) *DevicesCreateBulk {
	return &DevicesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DevicesClient) MapCreateBulk(slice any, setFunc func(*DevicesCreate, int)) *DevicesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DevicesCreateBulk{err: fmt.Errorf("calling to DevicesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DevicesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DevicesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Devices.
func (c *DevicesClient) Update() *DevicesUpdate {
	mutation := newDevicesMutation(c.config, OpUpdate)
	return &DevicesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DevicesClient) UpdateOne(d *Devices) *DevicesUpdateOne {
	mutation := newDevicesMutation(c.config, OpUpdateOne, withDevices(d))
	return &DevicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DevicesClient) UpdateOneID(id uint64) *DevicesUpdateOne {
	mutation := newDevicesMutation(c.config, OpUpdateOne, withDevicesID(id))
	return &DevicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Devices.
func (c *DevicesClient) Delete() *DevicesDelete {
	mutation := newDevicesMutation(c.config, OpDelete)
	return &DevicesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DevicesClient) DeleteOne(d *Devices) *DevicesDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DevicesClient) DeleteOneID(id uint64) *DevicesDeleteOne {
	builder := c.Delete().Where(devices.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DevicesDeleteOne{builder}
}

// Query returns a query builder for Devices.
func (c *DevicesClient) Query() *DevicesQuery {
	return &DevicesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDevices},
		inters: c.Interceptors(),
	}
}

// Get returns a Devices entity by its id.
func (c *DevicesClient) Get(ctx context.Context, id uint64) (*Devices, error) {
	return c.Query().Where(devices.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DevicesClient) GetX(ctx context.Context, id uint64) *Devices {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Devices.
func (c *DevicesClient) QueryUser(d *Devices) *UsersQuery {
	query := (&UsersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devices.Table, devices.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, devices.UserTable, devices.UserColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DevicesClient) Hooks() []Hook {
	return c.hooks.Devices
}

// Interceptors returns the client interceptors.
func (c *DevicesClient) Interceptors() []Interceptor {
	return c.inters.Devices
}

func (c *DevicesClient) mutate(ctx context.Context, m *DevicesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DevicesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DevicesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DevicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DevicesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Devices mutation op: %q", m.Op())
	}
}

// DirectorsClient is a client for the Directors schema.
type DirectorsClient struct {
	config
}

// NewDirectorsClient returns a client for the Directors from the given config.
func NewDirectorsClient(c config) *DirectorsClient {
	return &DirectorsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `directors.Hooks(f(g(h())))`.
func (c *DirectorsClient) Use(hooks ...Hook) {
	c.hooks.Directors = append(c.hooks.Directors, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `directors.Intercept(f(g(h())))`.
func (c *DirectorsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Directors = append(c.inters.Directors, interceptors...)
}

// Create returns a builder for creating a Directors entity.
func (c *DirectorsClient) Create() *DirectorsCreate {
	mutation := newDirectorsMutation(c.config, OpCreate)
	return &DirectorsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Directors entities.
func (c *DirectorsClient) CreateBulk(builders ...*DirectorsCreate) *DirectorsCreateBulk {
	return &DirectorsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DirectorsClient) MapCreateBulk(slice any, setFunc func(*DirectorsCreate, int)) *DirectorsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DirectorsCreateBulk{err: fmt.Errorf("calling to DirectorsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DirectorsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DirectorsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Directors.
func (c *DirectorsClient) Update() *DirectorsUpdate {
	mutation := newDirectorsMutation(c.config, OpUpdate)
	return &DirectorsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DirectorsClient) UpdateOne(d *Directors) *DirectorsUpdateOne {
	mutation := newDirectorsMutation(c.config, OpUpdateOne, withDirectors(d))
	return &DirectorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DirectorsClient) UpdateOneID(id int) *DirectorsUpdateOne {
	mutation := newDirectorsMutation(c.config, OpUpdateOne, withDirectorsID(id))
	return &DirectorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Directors.
func (c *DirectorsClient) Delete() *DirectorsDelete {
	mutation := newDirectorsMutation(c.config, OpDelete)
	return &DirectorsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DirectorsClient) DeleteOne(d *Directors) *DirectorsDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DirectorsClient) DeleteOneID(id int) *DirectorsDeleteOne {
	builder := c.Delete().Where(directors.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DirectorsDeleteOne{builder}
}

// Query returns a query builder for Directors.
func (c *DirectorsClient) Query() *DirectorsQuery {
	return &DirectorsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDirectors},
		inters: c.Interceptors(),
	}
}

// Get returns a Directors entity by its id.
func (c *DirectorsClient) Get(ctx context.Context, id int) (*Directors, error) {
	return c.Query().Where(directors.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DirectorsClient) GetX(ctx context.Context, id int) *Directors {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DirectorsClient) Hooks() []Hook {
	return c.hooks.Directors
}

// Interceptors returns the client interceptors.
func (c *DirectorsClient) Interceptors() []Interceptor {
	return c.inters.Directors
}

func (c *DirectorsClient) mutate(ctx context.Context, m *DirectorsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DirectorsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DirectorsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DirectorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DirectorsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Directors mutation op: %q", m.Op())
	}
}

// FilesClient is a client for the Files schema.
type FilesClient struct {
	config
}

// NewFilesClient returns a client for the Files from the given config.
func NewFilesClient(c config) *FilesClient {
	return &FilesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `files.Hooks(f(g(h())))`.
func (c *FilesClient) Use(hooks ...Hook) {
	c.hooks.Files = append(c.hooks.Files, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `files.Intercept(f(g(h())))`.
func (c *FilesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Files = append(c.inters.Files, interceptors...)
}

// Create returns a builder for creating a Files entity.
func (c *FilesClient) Create() *FilesCreate {
	mutation := newFilesMutation(c.config, OpCreate)
	return &FilesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Files entities.
func (c *FilesClient) CreateBulk(builders ...*FilesCreate) *FilesCreateBulk {
	return &FilesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FilesClient) MapCreateBulk(slice any, setFunc func(*FilesCreate, int)) *FilesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FilesCreateBulk{err: fmt.Errorf("calling to FilesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FilesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FilesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Files.
func (c *FilesClient) Update() *FilesUpdate {
	mutation := newFilesMutation(c.config, OpUpdate)
	return &FilesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FilesClient) UpdateOne(f *Files) *FilesUpdateOne {
	mutation := newFilesMutation(c.config, OpUpdateOne, withFiles(f))
	return &FilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FilesClient) UpdateOneID(id uint64) *FilesUpdateOne {
	mutation := newFilesMutation(c.config, OpUpdateOne, withFilesID(id))
	return &FilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Files.
func (c *FilesClient) Delete() *FilesDelete {
	mutation := newFilesMutation(c.config, OpDelete)
	return &FilesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FilesClient) DeleteOne(f *Files) *FilesDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FilesClient) DeleteOneID(id uint64) *FilesDeleteOne {
	builder := c.Delete().Where(files.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FilesDeleteOne{builder}
}

// Query returns a query builder for Files.
func (c *FilesClient) Query() *FilesQuery {
	return &FilesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFiles},
		inters: c.Interceptors(),
	}
}

// Get returns a Files entity by its id.
func (c *FilesClient) Get(ctx context.Context, id uint64) (*Files, error) {
	return c.Query().Where(files.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FilesClient) GetX(ctx context.Context, id uint64) *Files {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMusics queries the musics edge of a Files.
func (c *FilesClient) QueryMusics(f *Files) *MusicsQuery {
	query := (&MusicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(files.Table, files.FieldID, id),
			sqlgraph.To(musics.Table, musics.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, files.MusicsTable, files.MusicsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImages queries the images edge of a Files.
func (c *FilesClient) QueryImages(f *Files) *ImagesQuery {
	query := (&ImagesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(files.Table, files.FieldID, id),
			sqlgraph.To(images.Table, images.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, files.ImagesTable, files.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FilesClient) Hooks() []Hook {
	return c.hooks.Files
}

// Interceptors returns the client interceptors.
func (c *FilesClient) Interceptors() []Interceptor {
	return c.inters.Files
}

func (c *FilesClient) mutate(ctx context.Context, m *FilesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FilesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FilesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FilesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Files mutation op: %q", m.Op())
	}
}

// ImagesClient is a client for the Images schema.
type ImagesClient struct {
	config
}

// NewImagesClient returns a client for the Images from the given config.
func NewImagesClient(c config) *ImagesClient {
	return &ImagesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `images.Hooks(f(g(h())))`.
func (c *ImagesClient) Use(hooks ...Hook) {
	c.hooks.Images = append(c.hooks.Images, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `images.Intercept(f(g(h())))`.
func (c *ImagesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Images = append(c.inters.Images, interceptors...)
}

// Create returns a builder for creating a Images entity.
func (c *ImagesClient) Create() *ImagesCreate {
	mutation := newImagesMutation(c.config, OpCreate)
	return &ImagesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Images entities.
func (c *ImagesClient) CreateBulk(builders ...*ImagesCreate) *ImagesCreateBulk {
	return &ImagesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImagesClient) MapCreateBulk(slice any, setFunc func(*ImagesCreate, int)) *ImagesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImagesCreateBulk{err: fmt.Errorf("calling to ImagesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImagesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImagesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Images.
func (c *ImagesClient) Update() *ImagesUpdate {
	mutation := newImagesMutation(c.config, OpUpdate)
	return &ImagesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImagesClient) UpdateOne(i *Images) *ImagesUpdateOne {
	mutation := newImagesMutation(c.config, OpUpdateOne, withImages(i))
	return &ImagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImagesClient) UpdateOneID(id uint64) *ImagesUpdateOne {
	mutation := newImagesMutation(c.config, OpUpdateOne, withImagesID(id))
	return &ImagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Images.
func (c *ImagesClient) Delete() *ImagesDelete {
	mutation := newImagesMutation(c.config, OpDelete)
	return &ImagesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImagesClient) DeleteOne(i *Images) *ImagesDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImagesClient) DeleteOneID(id uint64) *ImagesDeleteOne {
	builder := c.Delete().Where(images.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImagesDeleteOne{builder}
}

// Query returns a query builder for Images.
func (c *ImagesClient) Query() *ImagesQuery {
	return &ImagesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImages},
		inters: c.Interceptors(),
	}
}

// Get returns a Images entity by its id.
func (c *ImagesClient) Get(ctx context.Context, id uint64) (*Images, error) {
	return c.Query().Where(images.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImagesClient) GetX(ctx context.Context, id uint64) *Images {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a Images.
func (c *ImagesClient) QueryFile(i *Images) *FilesQuery {
	query := (&FilesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(images.Table, images.FieldID, id),
			sqlgraph.To(files.Table, files.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, images.FileTable, images.FileColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlbums queries the albums edge of a Images.
func (c *ImagesClient) QueryAlbums(i *Images) *AlbumsQuery {
	query := (&AlbumsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(images.Table, images.FieldID, id),
			sqlgraph.To(albums.Table, albums.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, images.AlbumsTable, images.AlbumsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaylists queries the playlists edge of a Images.
func (c *ImagesClient) QueryPlaylists(i *Images) *PlaylistsQuery {
	query := (&PlaylistsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(images.Table, images.FieldID, id),
			sqlgraph.To(playlists.Table, playlists.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, images.PlaylistsTable, images.PlaylistsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImagesClient) Hooks() []Hook {
	return c.hooks.Images
}

// Interceptors returns the client interceptors.
func (c *ImagesClient) Interceptors() []Interceptor {
	return c.inters.Images
}

func (c *ImagesClient) mutate(ctx context.Context, m *ImagesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImagesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImagesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImagesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImagesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Images mutation op: %q", m.Op())
	}
}

// MusicsClient is a client for the Musics schema.
type MusicsClient struct {
	config
}

// NewMusicsClient returns a client for the Musics from the given config.
func NewMusicsClient(c config) *MusicsClient {
	return &MusicsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `musics.Hooks(f(g(h())))`.
func (c *MusicsClient) Use(hooks ...Hook) {
	c.hooks.Musics = append(c.hooks.Musics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `musics.Intercept(f(g(h())))`.
func (c *MusicsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Musics = append(c.inters.Musics, interceptors...)
}

// Create returns a builder for creating a Musics entity.
func (c *MusicsClient) Create() *MusicsCreate {
	mutation := newMusicsMutation(c.config, OpCreate)
	return &MusicsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Musics entities.
func (c *MusicsClient) CreateBulk(builders ...*MusicsCreate) *MusicsCreateBulk {
	return &MusicsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MusicsClient) MapCreateBulk(slice any, setFunc func(*MusicsCreate, int)) *MusicsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MusicsCreateBulk{err: fmt.Errorf("calling to MusicsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MusicsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MusicsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Musics.
func (c *MusicsClient) Update() *MusicsUpdate {
	mutation := newMusicsMutation(c.config, OpUpdate)
	return &MusicsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MusicsClient) UpdateOne(m *Musics) *MusicsUpdateOne {
	mutation := newMusicsMutation(c.config, OpUpdateOne, withMusics(m))
	return &MusicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MusicsClient) UpdateOneID(id uint64) *MusicsUpdateOne {
	mutation := newMusicsMutation(c.config, OpUpdateOne, withMusicsID(id))
	return &MusicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Musics.
func (c *MusicsClient) Delete() *MusicsDelete {
	mutation := newMusicsMutation(c.config, OpDelete)
	return &MusicsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MusicsClient) DeleteOne(m *Musics) *MusicsDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MusicsClient) DeleteOneID(id uint64) *MusicsDeleteOne {
	builder := c.Delete().Where(musics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MusicsDeleteOne{builder}
}

// Query returns a query builder for Musics.
func (c *MusicsClient) Query() *MusicsQuery {
	return &MusicsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMusics},
		inters: c.Interceptors(),
	}
}

// Get returns a Musics entity by its id.
func (c *MusicsClient) Get(ctx context.Context, id uint64) (*Musics, error) {
	return c.Query().Where(musics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MusicsClient) GetX(ctx context.Context, id uint64) *Musics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Musics.
func (c *MusicsClient) QueryUsers(m *Musics) *UsersQuery {
	query := (&UsersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(musics.Table, musics.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, musics.UsersTable, musics.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a Musics.
func (c *MusicsClient) QueryFile(m *Musics) *FilesQuery {
	query := (&FilesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(musics.Table, musics.FieldID, id),
			sqlgraph.To(files.Table, files.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, musics.FileTable, musics.FileColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtists queries the artists edge of a Musics.
func (c *MusicsClient) QueryArtists(m *Musics) *ArtistsQuery {
	query := (&ArtistsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(musics.Table, musics.FieldID, id),
			sqlgraph.To(artists.Table, artists.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, musics.ArtistsTable, musics.ArtistsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaylists queries the playlists edge of a Musics.
func (c *MusicsClient) QueryPlaylists(m *Musics) *PlaylistsQuery {
	query := (&PlaylistsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(musics.Table, musics.FieldID, id),
			sqlgraph.To(playlists.Table, playlists.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, musics.PlaylistsTable, musics.PlaylistsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlbums queries the albums edge of a Musics.
func (c *MusicsClient) QueryAlbums(m *Musics) *AlbumsQuery {
	query := (&AlbumsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(musics.Table, musics.FieldID, id),
			sqlgraph.To(albums.Table, albums.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, musics.AlbumsTable, musics.AlbumsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MusicsClient) Hooks() []Hook {
	return c.hooks.Musics
}

// Interceptors returns the client interceptors.
func (c *MusicsClient) Interceptors() []Interceptor {
	return c.inters.Musics
}

func (c *MusicsClient) mutate(ctx context.Context, m *MusicsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MusicsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MusicsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MusicsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MusicsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Musics mutation op: %q", m.Op())
	}
}

// OidcClient is a client for the Oidc schema.
type OidcClient struct {
	config
}

// NewOidcClient returns a client for the Oidc from the given config.
func NewOidcClient(c config) *OidcClient {
	return &OidcClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oidc.Hooks(f(g(h())))`.
func (c *OidcClient) Use(hooks ...Hook) {
	c.hooks.Oidc = append(c.hooks.Oidc, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oidc.Intercept(f(g(h())))`.
func (c *OidcClient) Intercept(interceptors ...Interceptor) {
	c.inters.Oidc = append(c.inters.Oidc, interceptors...)
}

// Create returns a builder for creating a Oidc entity.
func (c *OidcClient) Create() *OidcCreate {
	mutation := newOidcMutation(c.config, OpCreate)
	return &OidcCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Oidc entities.
func (c *OidcClient) CreateBulk(builders ...*OidcCreate) *OidcCreateBulk {
	return &OidcCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OidcClient) MapCreateBulk(slice any, setFunc func(*OidcCreate, int)) *OidcCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OidcCreateBulk{err: fmt.Errorf("calling to OidcClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OidcCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OidcCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Oidc.
func (c *OidcClient) Update() *OidcUpdate {
	mutation := newOidcMutation(c.config, OpUpdate)
	return &OidcUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OidcClient) UpdateOne(o *Oidc) *OidcUpdateOne {
	mutation := newOidcMutation(c.config, OpUpdateOne, withOidc(o))
	return &OidcUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OidcClient) UpdateOneID(id uint64) *OidcUpdateOne {
	mutation := newOidcMutation(c.config, OpUpdateOne, withOidcID(id))
	return &OidcUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Oidc.
func (c *OidcClient) Delete() *OidcDelete {
	mutation := newOidcMutation(c.config, OpDelete)
	return &OidcDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OidcClient) DeleteOne(o *Oidc) *OidcDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OidcClient) DeleteOneID(id uint64) *OidcDeleteOne {
	builder := c.Delete().Where(oidc.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OidcDeleteOne{builder}
}

// Query returns a query builder for Oidc.
func (c *OidcClient) Query() *OidcQuery {
	return &OidcQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOidc},
		inters: c.Interceptors(),
	}
}

// Get returns a Oidc entity by its id.
func (c *OidcClient) Get(ctx context.Context, id uint64) (*Oidc, error) {
	return c.Query().Where(oidc.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OidcClient) GetX(ctx context.Context, id uint64) *Oidc {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OidcClient) Hooks() []Hook {
	return c.hooks.Oidc
}

// Interceptors returns the client interceptors.
func (c *OidcClient) Interceptors() []Interceptor {
	return c.inters.Oidc
}

func (c *OidcClient) mutate(ctx context.Context, m *OidcMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OidcCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OidcUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OidcUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OidcDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Oidc mutation op: %q", m.Op())
	}
}

// PlaylistsClient is a client for the Playlists schema.
type PlaylistsClient struct {
	config
}

// NewPlaylistsClient returns a client for the Playlists from the given config.
func NewPlaylistsClient(c config) *PlaylistsClient {
	return &PlaylistsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `playlists.Hooks(f(g(h())))`.
func (c *PlaylistsClient) Use(hooks ...Hook) {
	c.hooks.Playlists = append(c.hooks.Playlists, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `playlists.Intercept(f(g(h())))`.
func (c *PlaylistsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Playlists = append(c.inters.Playlists, interceptors...)
}

// Create returns a builder for creating a Playlists entity.
func (c *PlaylistsClient) Create() *PlaylistsCreate {
	mutation := newPlaylistsMutation(c.config, OpCreate)
	return &PlaylistsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Playlists entities.
func (c *PlaylistsClient) CreateBulk(builders ...*PlaylistsCreate) *PlaylistsCreateBulk {
	return &PlaylistsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlaylistsClient) MapCreateBulk(slice any, setFunc func(*PlaylistsCreate, int)) *PlaylistsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlaylistsCreateBulk{err: fmt.Errorf("calling to PlaylistsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlaylistsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlaylistsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Playlists.
func (c *PlaylistsClient) Update() *PlaylistsUpdate {
	mutation := newPlaylistsMutation(c.config, OpUpdate)
	return &PlaylistsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlaylistsClient) UpdateOne(pl *Playlists) *PlaylistsUpdateOne {
	mutation := newPlaylistsMutation(c.config, OpUpdateOne, withPlaylists(pl))
	return &PlaylistsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlaylistsClient) UpdateOneID(id uint64) *PlaylistsUpdateOne {
	mutation := newPlaylistsMutation(c.config, OpUpdateOne, withPlaylistsID(id))
	return &PlaylistsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Playlists.
func (c *PlaylistsClient) Delete() *PlaylistsDelete {
	mutation := newPlaylistsMutation(c.config, OpDelete)
	return &PlaylistsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlaylistsClient) DeleteOne(pl *Playlists) *PlaylistsDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlaylistsClient) DeleteOneID(id uint64) *PlaylistsDeleteOne {
	builder := c.Delete().Where(playlists.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlaylistsDeleteOne{builder}
}

// Query returns a query builder for Playlists.
func (c *PlaylistsClient) Query() *PlaylistsQuery {
	return &PlaylistsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlaylists},
		inters: c.Interceptors(),
	}
}

// Get returns a Playlists entity by its id.
func (c *PlaylistsClient) Get(ctx context.Context, id uint64) (*Playlists, error) {
	return c.Query().Where(playlists.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlaylistsClient) GetX(ctx context.Context, id uint64) *Playlists {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Playlists.
func (c *PlaylistsClient) QueryOwner(pl *Playlists) *UsersQuery {
	query := (&UsersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playlists.Table, playlists.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, playlists.OwnerTable, playlists.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMusics queries the musics edge of a Playlists.
func (c *PlaylistsClient) QueryMusics(pl *Playlists) *MusicsQuery {
	query := (&MusicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playlists.Table, playlists.FieldID, id),
			sqlgraph.To(musics.Table, musics.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, playlists.MusicsTable, playlists.MusicsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImage queries the image edge of a Playlists.
func (c *PlaylistsClient) QueryImage(pl *Playlists) *ImagesQuery {
	query := (&ImagesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playlists.Table, playlists.FieldID, id),
			sqlgraph.To(images.Table, images.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, playlists.ImageTable, playlists.ImageColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlaylistsClient) Hooks() []Hook {
	return c.hooks.Playlists
}

// Interceptors returns the client interceptors.
func (c *PlaylistsClient) Interceptors() []Interceptor {
	return c.inters.Playlists
}

func (c *PlaylistsClient) mutate(ctx context.Context, m *PlaylistsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlaylistsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlaylistsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlaylistsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlaylistsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Playlists mutation op: %q", m.Op())
	}
}

// UsersClient is a client for the Users schema.
type UsersClient struct {
	config
}

// NewUsersClient returns a client for the Users from the given config.
func NewUsersClient(c config) *UsersClient {
	return &UsersClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `users.Hooks(f(g(h())))`.
func (c *UsersClient) Use(hooks ...Hook) {
	c.hooks.Users = append(c.hooks.Users, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `users.Intercept(f(g(h())))`.
func (c *UsersClient) Intercept(interceptors ...Interceptor) {
	c.inters.Users = append(c.inters.Users, interceptors...)
}

// Create returns a builder for creating a Users entity.
func (c *UsersClient) Create() *UsersCreate {
	mutation := newUsersMutation(c.config, OpCreate)
	return &UsersCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Users entities.
func (c *UsersClient) CreateBulk(builders ...*UsersCreate) *UsersCreateBulk {
	return &UsersCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UsersClient) MapCreateBulk(slice any, setFunc func(*UsersCreate, int)) *UsersCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UsersCreateBulk{err: fmt.Errorf("calling to UsersClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UsersCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UsersCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Users.
func (c *UsersClient) Update() *UsersUpdate {
	mutation := newUsersMutation(c.config, OpUpdate)
	return &UsersUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UsersClient) UpdateOne(u *Users) *UsersUpdateOne {
	mutation := newUsersMutation(c.config, OpUpdateOne, withUsers(u))
	return &UsersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UsersClient) UpdateOneID(id uint64) *UsersUpdateOne {
	mutation := newUsersMutation(c.config, OpUpdateOne, withUsersID(id))
	return &UsersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Users.
func (c *UsersClient) Delete() *UsersDelete {
	mutation := newUsersMutation(c.config, OpDelete)
	return &UsersDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UsersClient) DeleteOne(u *Users) *UsersDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UsersClient) DeleteOneID(id uint64) *UsersDeleteOne {
	builder := c.Delete().Where(users.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UsersDeleteOne{builder}
}

// Query returns a query builder for Users.
func (c *UsersClient) Query() *UsersQuery {
	return &UsersQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUsers},
		inters: c.Interceptors(),
	}
}

// Get returns a Users entity by its id.
func (c *UsersClient) Get(ctx context.Context, id uint64) (*Users, error) {
	return c.Query().Where(users.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UsersClient) GetX(ctx context.Context, id uint64) *Users {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDevices queries the devices edge of a Users.
func (c *UsersClient) QueryDevices(u *Users) *DevicesQuery {
	query := (&DevicesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(devices.Table, devices.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, users.DevicesTable, users.DevicesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlaylists queries the playlists edge of a Users.
func (c *UsersClient) QueryPlaylists(u *Users) *PlaylistsQuery {
	query := (&PlaylistsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(playlists.Table, playlists.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, users.PlaylistsTable, users.PlaylistsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlbums queries the albums edge of a Users.
func (c *UsersClient) QueryAlbums(u *Users) *AlbumsQuery {
	query := (&AlbumsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(albums.Table, albums.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, users.AlbumsTable, users.AlbumsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMusics queries the musics edge of a Users.
func (c *UsersClient) QueryMusics(u *Users) *MusicsQuery {
	query := (&MusicsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(musics.Table, musics.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, users.MusicsTable, users.MusicsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UsersClient) Hooks() []Hook {
	return c.hooks.Users
}

// Interceptors returns the client interceptors.
func (c *UsersClient) Interceptors() []Interceptor {
	return c.inters.Users
}

func (c *UsersClient) mutate(ctx context.Context, m *UsersMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UsersCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UsersUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UsersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UsersDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Users mutation op: %q", m.Op())
	}
}

// VideosClient is a client for the Videos schema.
type VideosClient struct {
	config
}

// NewVideosClient returns a client for the Videos from the given config.
func NewVideosClient(c config) *VideosClient {
	return &VideosClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `videos.Hooks(f(g(h())))`.
func (c *VideosClient) Use(hooks ...Hook) {
	c.hooks.Videos = append(c.hooks.Videos, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `videos.Intercept(f(g(h())))`.
func (c *VideosClient) Intercept(interceptors ...Interceptor) {
	c.inters.Videos = append(c.inters.Videos, interceptors...)
}

// Create returns a builder for creating a Videos entity.
func (c *VideosClient) Create() *VideosCreate {
	mutation := newVideosMutation(c.config, OpCreate)
	return &VideosCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Videos entities.
func (c *VideosClient) CreateBulk(builders ...*VideosCreate) *VideosCreateBulk {
	return &VideosCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideosClient) MapCreateBulk(slice any, setFunc func(*VideosCreate, int)) *VideosCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideosCreateBulk{err: fmt.Errorf("calling to VideosClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideosCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideosCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Videos.
func (c *VideosClient) Update() *VideosUpdate {
	mutation := newVideosMutation(c.config, OpUpdate)
	return &VideosUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideosClient) UpdateOne(v *Videos) *VideosUpdateOne {
	mutation := newVideosMutation(c.config, OpUpdateOne, withVideos(v))
	return &VideosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideosClient) UpdateOneID(id int) *VideosUpdateOne {
	mutation := newVideosMutation(c.config, OpUpdateOne, withVideosID(id))
	return &VideosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Videos.
func (c *VideosClient) Delete() *VideosDelete {
	mutation := newVideosMutation(c.config, OpDelete)
	return &VideosDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideosClient) DeleteOne(v *Videos) *VideosDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideosClient) DeleteOneID(id int) *VideosDeleteOne {
	builder := c.Delete().Where(videos.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideosDeleteOne{builder}
}

// Query returns a query builder for Videos.
func (c *VideosClient) Query() *VideosQuery {
	return &VideosQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideos},
		inters: c.Interceptors(),
	}
}

// Get returns a Videos entity by its id.
func (c *VideosClient) Get(ctx context.Context, id int) (*Videos, error) {
	return c.Query().Where(videos.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideosClient) GetX(ctx context.Context, id int) *Videos {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VideosClient) Hooks() []Hook {
	return c.hooks.Videos
}

// Interceptors returns the client interceptors.
func (c *VideosClient) Interceptors() []Interceptor {
	return c.inters.Videos
}

func (c *VideosClient) mutate(ctx context.Context, m *VideosMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideosCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideosUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideosDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Videos mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Actors, Albums, Artists, Audiobooks, Categorys, Devices, Directors, Files,
		Images, Musics, Oidc, Playlists, Users, Videos []ent.Hook
	}
	inters struct {
		Actors, Albums, Artists, Audiobooks, Categorys, Devices, Directors, Files,
		Images, Musics, Oidc, Playlists, Users, Videos []ent.Interceptor
	}
)
